<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>CSC460 RTOS: A Simple RTOS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CSC460 RTOS
   </div>
   <div id="projectbrief">An RTOS adapted for the ATmega2560</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">A Simple RTOS </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a simple RTOS that supports pre-emptive multithreading.</p>
<p><b>Note:</b> Please don't edit the interface file "os.h".</p>
<dl class="section author"><dt>Author</dt><dd>Dr. Mantis Cheng </dd></dl>
<dl class="section date"><dt>Date</dt><dd>5 Feb 2015</dd></dl>
<h1><a class="anchor" id="assumptions"></a>
GLOBAL ASSUMPTIONS</h1>
<p>(ATMEL specific)</p><ul>
<li>Timer2 and SWI interrupts are reserved.</li>
<li>All runtime exceptions (where assumptions are violated) or other unrecoverable errors get handled by calling <a class="el" href="os_8h.html#a40cd786f232d0c4af0952cfc037addc6" title="Abort the execution of this RTOS due to an unrecoverable erorr. ">OS_Abort()</a>.</li>
<li>All unspecified runtime errors have undefined behaviours, e.g., stack overflow.</li>
</ul>
<p>Our RTOS scheduler timer resolution is defined by TICK. Hence, all timing parameters must be defined in multiples of TICKs. For PERIODIC tasks, its period, wcet and start time must be a multiple of TICKs. For RR tasks, its quantum is also defined in terms of TICKs.</p>
<h1><a class="anchor" id="policy"></a>
SCHEDULING POLICY</h1>
<p>There are three scheduling levels: SYSTEM, PERIODIC and RR. These levels are prioritized with SYSTEM being the highest, and RR being the lowest.</p>
<p>Preemption occurs immediately. Whenever preemption is feasible, it takes place instantly. As soon as a higher priority task becomes ready, it preempts all lower priority tasks.</p>
<h1><a class="anchor" id="system"></a>
SYSTEM TASKS</h1>
<p>SYSTEM (level) tasks are FCFS; they run to completion, i.e., until they terminate, block or yield. Thus, they are non-preemptible, not even by other SYSTEM tasks. They should only be used for critical system level activities, e.g., error or fault recovery. Running too many SYSTEM tasks could affect the real time performance of all other low level tasks, including PERIODIC tasks; therefore, use SYSTEM tasks sparingly and keep their execution time short.</p>
<h1><a class="anchor" id="periodic"></a>
PERIODIC TASKS</h1>
<p>PERIODIC tasks are scheduled based on a per-task scheduling period, worst-case execution time (wcet) and start time. Periodic tasks are time-critical; they are <b>NOT</b> allowed to wait on any synchronization primitives, e.g. <a class="el" href="os_8h.html#aee597502c326bc9ca1faeaa422dbbbf8">Service_Subscribe()</a>. For example,</p>
<p>void p() { ... }</p>
<p>e.g., Task_Create_Periodic( p, 0, 20, 1, 2 );</p>
<p>This will create a PERIODIC task executing the function p() with a period of 20 TICKs (100 msecs, or 10 Hz), a WCET of 1 TICK (5 msec) and will start 2 TICKs after booting. WCET must be less than the period.</p>
<p>That is, after 10 msecs, this task will execute at time 10, 110, 210, 310, etc., with a worst case execution time of 5 msec during each period of 100 msec.</p>
<p>It is an <b>error</b> (exception) if this task executes more than its wcet during each cycle.</p>
<p>This task may call <a class="el" href="os_8h.html#a5a9b72d0dadaea32fec8d4ff1c0eafa4" title="The calling task gives up its share of the processor voluntarily. ">Task_Next()</a> before its allowed WCET. The remaining time till the end of its period is known as its "DELAYED" time.</p>
<p>It is the responsibility of the Application Engineers to ensure that no two PERIODIC tasks overlapping in execution. It is an <b>error</b> if two PERIODIC tasks are ready at the same time!!! In other words, from the start of a periodic task until the end of its wcet, no other periodic task should be scheduled.</p>
<p>It is an <b>error</b> if a PERIODIC task executes longer than the allowed WCET. All timing violations should be caught and then reported. The task must call <a class="el" href="os_8h.html#a5a9b72d0dadaea32fec8d4ff1c0eafa4" title="The calling task gives up its share of the processor voluntarily. ">Task_Next()</a> before the expiry of its WCET.</p>
<p>When a PERIODIC task is preempted, its worst-case execution time will be stretched. In a similar way, when a RR task is preempted, its allowed quantum will be stretched. In theory, the RTOS should only accumulate the actual execution time; but in practice, the actual execution time could only be approximated due to the limitation of the scheduling timer resolution (1 TICK).</p>
<p>It is an error if a PERIODIC task waits on an Event.</p>
<h1><a class="anchor" id="roundrobin"></a>
ROUND-ROBIN TASKS</h1>
<p>RR tasks are FIFO, and they run at the lowest priority level. If a RR task becomes ready, it will be executed only when there are no other SYSTEM or PERIODIC tasks running. Each RR task gets one quantum that is 1 TICK in length. At the end of its quantum, a RR task is re-enqueued in the RR queue. However, if a RR task is preempted before its quantum expires, it re-enters at the front of its queue.</p>
<p>Only SYSTEM and RR tasks may wait for a service. Any task can send notifications over a service.</p>
<h1><a class="anchor" id="ipc"></a>
services</h1>
<p>Services are used to transfer data safely between tasks. Any number of tasks can wait on a service by calling <a class="el" href="os_8h.html#aee597502c326bc9ca1faeaa422dbbbf8">Service_Subscribe()</a>, at which point the calling task enters the WAITING state. A WAITING task does not wake up and return from Service_Subscribe until another task sends a notification to the service being waited on. Any running task may send a notification to a service by calling <a class="el" href="os_8h.html#aaa4dbf5e4da2f0aba1fff3b057e79389">Service_Publish()</a>. The notification contains a single 16-bit integer.</p>
<p>There is no way to guarantee that a service will receive a notification before a task's time slice expires, so PERIODIC tasks are not permitted to subscribe to services. If a PERIODIC task attempts to subscribe to a service, then it is a runtime error. However, PERIODIC tasks are permitted to publish notifications to a service. Interrupts can also publish to a service.</p>
<p>When a notification is published to a service, all subscribers are immediately woken and receive the message. Only the latest notificaton is stored. If a new notification comes in it overwrites the previous notification.</p>
<p>Example:</p><ul>
<li>A RR task that sends sensor values over a radio subscribes to a service</li>
<li>Three PERIODIC tasks read from three different ultrasonic range finders on a schedule</li>
<li>When one of the PERIODIC tasks has new data, it publishes a notification to the service</li>
<li>Every time the RR task receives a notification, it sends the received value over the radio.</li>
</ul>
<p>(this concept can be extended to RPC across several agents, but this feature is not required for project 2)</p>
<h1><a class="anchor" id="clock"></a>
CLOCK AND HIGH RESOLUTION TIMER</h1>
<p>Every RTOS should maintain a "clock" for simple timing services, e.g., measuring timing interval between two time epochs. The higher the resolution the clock, the more accurate the time measurement is. An RTOS also uses a timer for scheduling decision, e.g., when to run a PERIODIC task. If the scheduler is invoked very often, e.g., every millisecond, it will create an unacceptable overhead where a high percentage of CPU time is wasted on on scheduling decision and not executing user tasks. So, typically a 5 milliseconds scheduling interval is a good compromise between overhead and response time.</p>
<p><a class="el" href="os_8h.html#af421581f2b3d36a5ac9a205e035ae172">Now()</a> is our system clock which gives a millisecond accuracy for timing measurement. We use Timer2 for this purpose to generate a scheduling timer interrupt every 5 milliseconds. However, <a class="el" href="os_8h.html#af421581f2b3d36a5ac9a205e035ae172">Now()</a> should provide a time resolution of 1 millisecond. By combining the total number of TICKs and the current free running counter inside a timer, we can provide a more precise high resolution timer.</p>
<h1><a class="anchor" id="boot"></a>
OS BOOTING</h1>
<p>Our RTOS is compiled together with an application. The standard default "main()" function is defined inside the <a class="el" href="os_8c.html" title="A Real Time Operating System. ">os.c</a> file, which is essentially "OS_Init()". Application that uses this RTOS will define a new function called "r_main()" which will be created as the first SYSTEM level task.</p><ol type="1">
<li><a class="el" href="os_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> is called from crt0.S as the very first C function to be executed inside <a class="el" href="os_8c.html" title="A Real Time Operating System. ">os.c</a>.</li>
<li>Upon completion of RTOS initialization, the application's "r_main()" is created as the first and only SYSTEM level task.</li>
<li>In "r_main()", the rest of the application tasks are then created.</li>
<li>In order for all other application tasks to run, your "r_main() task
       must either terminate or block. (For example, "<a class="el" href="main_8c.html#afff05d20e8e3bfc1d7d8aab2bb3a1e9b" title="main function provided by user application. The first task to run. ">r_main()</a>"
       may become a "watchdog" task to reset the entire application.) </li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Mar 8 2015 13:21:08 for CSC460 RTOS by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
