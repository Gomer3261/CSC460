\section{N:/Documents/RTOS - CSC460/Assignments/Assignment2/Assignment2C/OS/os.c File Reference}
\label{os_8c}\index{N:/Documents/RTOS - CSC460/Assignments/Assignment2/Assignment2C/OS/os.c@{N:/Documents/RTOS - CSC460/Assignments/Assignment2/Assignment2C/OS/os.c}}
A Real Time Operating System. 

{\tt \#include $<$avr/io.h$>$}\par
{\tt \#include $<$avr/interrupt.h$>$}\par
{\tt \#include \char`\"{}os.h\char`\"{}}\par
{\tt \#include \char`\"{}kernel.h\char`\"{}}\par
{\tt \#include \char`\"{}error\_\-code.h\char`\"{}}\par
\subsection*{Defines}
\begin{CompactItemize}
\item 
\#define {\bf USE\_\-AVR2560\_\-GREATER}~1
\item 
\#define {\bf STACKCONTEXTSIZE}~(32 + 1 + 1 + 3 + 3)
\item 
\#define {\bf KERNELARG\_\-STACKOFFSET}~(32 + 1 + 1 + 1)
\item 
\#define {\bf SAVE\_\-CTX\_\-TOP}()
\item 
\#define {\bf STACK\_\-SREG\_\-SET\_\-I\_\-BIT}()
\item 
\#define {\bf SAVE\_\-CTX\_\-BOTTOM}()
\item 
\#define {\bf SAVE\_\-CTX}()~SAVE\_\-CTX\_\-TOP();SAVE\_\-CTX\_\-BOTTOM();
\begin{CompactList}\small\item\em Push all the registers and SREG onto the stack. \item\end{CompactList}\item 
\#define {\bf RESTORE\_\-CTX\_\-BOTTOM}()
\item 
\#define {\bf RESTORE\_\-CTX\_\-TOP}()
\item 
\#define {\bf RESTORE\_\-CTX}()~RESTORE\_\-CTX\_\-BOTTOM();RESTORE\_\-CTX\_\-TOP();
\begin{CompactList}\small\item\em Pop all registers and the status register. \item\end{CompactList}\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
int {\bf main} ()
\begin{CompactList}\small\item\em main function provided by user application. The first task to run. \item\end{CompactList}\item 
void {\bf TIMER1\_\-COMPA\_\-vect} (void)
\begin{CompactList}\small\item\em The interrupt handler for output compare interrupts on Timer 1. \item\end{CompactList}\item 
void {\bf OS\_\-Init} ()
\begin{CompactList}\small\item\em Setup the RTOS and create {\bf main()}{\rm (p.\,\pageref{_assignment2_8c_840291bc02cba5474a4cb46a9b9566fe})} as the first SYSTEM level task. \item\end{CompactList}\item 
void {\bf OS\_\-Abort} (void)
\begin{CompactList}\small\item\em Abort the execution of this RTOS due to an unrecoverable erorr. \item\end{CompactList}\item 
int {\bf Task\_\-Create} (void($\ast$f)(void), int arg, unsigned int level, unsigned int name)
\item 
void {\bf Task\_\-Next} ()
\begin{CompactList}\small\item\em The calling task gives up its share of the processor voluntarily. \item\end{CompactList}\item 
void {\bf Task\_\-Terminate} ()
\begin{CompactList}\small\item\em The calling task terminates itself. \item\end{CompactList}\item 
int {\bf Task\_\-Get\-Arg} (void)
\begin{CompactList}\small\item\em Retrieve the assigned parameter. \item\end{CompactList}\item 
{\bf EVENT} $\ast$ {\bf Event\_\-Init} (void)
\begin{CompactList}\small\item\em Initialize a new, non-NULL Event descriptor. \item\end{CompactList}\item 
void {\bf Event\_\-Wait} ({\bf EVENT} $\ast$e)
\begin{CompactList}\small\item\em Wait for the next occurrence of a signal on {\em e\/}. The calling process always blocks. \item\end{CompactList}\item 
void {\bf Event\_\-Signal} ({\bf EVENT} $\ast$e)
\begin{CompactList}\small\item\em Resume a {\bf single} waiting task on {\em e\/}. It is a {\em no-op\/} if there is no waiting process. \item\end{CompactList}\item 
void {\bf Event\_\-Broadcast} ({\bf EVENT} $\ast$e)
\begin{CompactList}\small\item\em Resume {\bf ALL} waiting tasks on {\em e\/}. It is a {\em no-op\/} if there is no waiting process. \item\end{CompactList}\item 
void {\bf Signal\_\-And\_\-Next} ({\bf EVENT} $\ast$e)
\begin{CompactList}\small\item\em Resume a waiting task on {\em e\/} and at the same time relinquish the processor. \item\end{CompactList}\item 
void {\bf Broadcast\_\-And\_\-Next} ({\bf EVENT} $\ast$e)
\begin{CompactList}\small\item\em Resume {\bf ALL} waiting tasks on {\em e\/} and at the same time relinquish the processor. \item\end{CompactList}\end{CompactItemize}
\subsection*{Variables}
\begin{CompactItemize}
\item 
const unsigned char {\bf PPP} [$\,$]
\item 
const unsigned int {\bf PT}
\end{CompactItemize}


\subsection{Detailed Description}
A Real Time Operating System. 

Our implementation of the operating system described by Mantis Cheng in {\bf os.h}{\rm (p.\,\pageref{os_8h})}.

\begin{Desc}
\item[Author:]Scott Craig 

Justin Tanner \end{Desc}


\subsection{Define Documentation}
\index{os.c@{os.c}!KERNELARG_STACKOFFSET@{KERNELARG\_\-STACKOFFSET}}
\index{KERNELARG_STACKOFFSET@{KERNELARG\_\-STACKOFFSET}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define KERNELARG\_\-STACKOFFSET~(32 + 1 + 1 + 1)}\label{os_8c_4ca901a3c767870093be57d271afc51e}


\index{os.c@{os.c}!RESTORE_CTX@{RESTORE\_\-CTX}}
\index{RESTORE_CTX@{RESTORE\_\-CTX}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define RESTORE\_\-CTX()~RESTORE\_\-CTX\_\-BOTTOM();RESTORE\_\-CTX\_\-TOP();}\label{os_8c_a48fc0927da8c8abbe88e67573b389c9}


Pop all registers and the status register. 

\index{os.c@{os.c}!RESTORE_CTX_BOTTOM@{RESTORE\_\-CTX\_\-BOTTOM}}
\index{RESTORE_CTX_BOTTOM@{RESTORE\_\-CTX\_\-BOTTOM}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define RESTORE\_\-CTX\_\-BOTTOM()}\label{os_8c_6002f8099b24e6c7903df21a754f1d6b}


\index{os.c@{os.c}!RESTORE_CTX_TOP@{RESTORE\_\-CTX\_\-TOP}}
\index{RESTORE_CTX_TOP@{RESTORE\_\-CTX\_\-TOP}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define RESTORE\_\-CTX\_\-TOP()}\label{os_8c_c79aff233b9171c3cacaf6ddffe8014a}


{\bf Value:}

\footnotesize\begin{verbatim}asm volatile (\
    "pop    r31             \n\t"\
        "out    __SREG__, r31   \n\t"\
        "pop    r31             \n\t"\
        "out    0X3C, r31       \n\t"\
        "pop    r31             \n\t"::);
\end{verbatim}\normalsize 
\index{os.c@{os.c}!SAVE_CTX@{SAVE\_\-CTX}}
\index{SAVE_CTX@{SAVE\_\-CTX}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define SAVE\_\-CTX()~SAVE\_\-CTX\_\-TOP();SAVE\_\-CTX\_\-BOTTOM();}\label{os_8c_d70a92eee8278b45f6aad877e23e0d3f}


Push all the registers and SREG onto the stack. 

\index{os.c@{os.c}!SAVE_CTX_BOTTOM@{SAVE\_\-CTX\_\-BOTTOM}}
\index{SAVE_CTX_BOTTOM@{SAVE\_\-CTX\_\-BOTTOM}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define SAVE\_\-CTX\_\-BOTTOM()}\label{os_8c_9250d18ad0a0ff5171eed2dc5f4e18d4}


\index{os.c@{os.c}!SAVE_CTX_TOP@{SAVE\_\-CTX\_\-TOP}}
\index{SAVE_CTX_TOP@{SAVE\_\-CTX\_\-TOP}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define SAVE\_\-CTX\_\-TOP()}\label{os_8c_c8ed78dfc7cf1438e51909e988a8e6aa}


{\bf Value:}

\footnotesize\begin{verbatim}asm volatile (\
    "push   r31             \n\t"\
    "in     r31,0X3C        \n\t"\
    "push   r31             \n\t"\
    "in     r31,__SREG__    \n\t"\
        "cli                    \n\t"::);
\end{verbatim}\normalsize 
It is important to keep the order of context saving and restoring exactly in reverse. Also, when a new task is created, it is important to initialize its \char`\"{}initial\char`\"{} context in the same order as a saved context.

Save r31 and SREG on stack, disable interrupts, then save the rest of the registers on the stack. In the locations this macro is used, the interrupts need to be disabled, or they already are disabled. \index{os.c@{os.c}!STACK_SREG_SET_I_BIT@{STACK\_\-SREG\_\-SET\_\-I\_\-BIT}}
\index{STACK_SREG_SET_I_BIT@{STACK\_\-SREG\_\-SET\_\-I\_\-BIT}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define STACK\_\-SREG\_\-SET\_\-I\_\-BIT()}\label{os_8c_dadefdf0cfb4066c6439cd200093c456}


{\bf Value:}

\footnotesize\begin{verbatim}asm volatile (\
    "ori    r31, 0x80        \n\t"::);
\end{verbatim}\normalsize 
\index{os.c@{os.c}!STACKCONTEXTSIZE@{STACKCONTEXTSIZE}}
\index{STACKCONTEXTSIZE@{STACKCONTEXTSIZE}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define STACKCONTEXTSIZE~(32 + 1 + 1 + 3 + 3)}\label{os_8c_dc80b18f37f24eb0f8bc27ca56e65d4b}


\index{os.c@{os.c}!USE_AVR2560_GREATER@{USE\_\-AVR2560\_\-GREATER}}
\index{USE_AVR2560_GREATER@{USE\_\-AVR2560\_\-GREATER}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define USE\_\-AVR2560\_\-GREATER~1}\label{os_8c_13f1ce8d1aeefce0b0d42cc7bad81fa1}




\subsection{Function Documentation}
\index{os.c@{os.c}!Broadcast_And_Next@{Broadcast\_\-And\_\-Next}}
\index{Broadcast_And_Next@{Broadcast\_\-And\_\-Next}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Broadcast\_\-And\_\-Next ({\bf EVENT} $\ast$ {\em e})}\label{os_8c_8530ed5f351b8835f3b060407bd68625}


Resume {\bf ALL} waiting tasks on {\em e\/} and at the same time relinquish the processor. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em e}]an Event descriptor\end{description}
\end{Desc}
This is equivalent to \char`\"{}Event\_\-Broadcast( e ); Task\_\-Next()\char`\"{} in concept. \begin{Desc}
\item[See also:]{\bf Event\_\-Broadcast()}{\rm (p.\,\pageref{os_8c_93f9686857f1f8cc4fe1585df3de4874})}, {\bf Task\_\-Next()}{\rm (p.\,\pageref{os_8c_5a9b72d0dadaea32fec8d4ff1c0eafa4})} \end{Desc}
\index{os.c@{os.c}!Event_Broadcast@{Event\_\-Broadcast}}
\index{Event_Broadcast@{Event\_\-Broadcast}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Event\_\-Broadcast ({\bf EVENT} $\ast$ {\em e})}\label{os_8c_93f9686857f1f8cc4fe1585df3de4874}


Resume {\bf ALL} waiting tasks on {\em e\/}. It is a {\em no-op\/} if there is no waiting process. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em e}]an Event descriptor\end{description}
\end{Desc}
\begin{Desc}
\item[See also:]{\bf Event\_\-Wait()}{\rm (p.\,\pageref{os_8c_e279428ffa0e59261a01899cea931503})} \end{Desc}
\index{os.c@{os.c}!Event_Init@{Event\_\-Init}}
\index{Event_Init@{Event\_\-Init}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf EVENT}$\ast$ Event\_\-Init (void)}\label{os_8c_852c4f8ed9198c7c996cc5e9ce7f1f2b}


Initialize a new, non-NULL Event descriptor. 

\begin{Desc}
\item[Returns:]a non-NULL Event descriptor if successful; NULL otherwise. \end{Desc}
\index{os.c@{os.c}!Event_Signal@{Event\_\-Signal}}
\index{Event_Signal@{Event\_\-Signal}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Event\_\-Signal ({\bf EVENT} $\ast$ {\em e})}\label{os_8c_39210e081be158dab105c68cb85585cd}


Resume a {\bf single} waiting task on {\em e\/}. It is a {\em no-op\/} if there is no waiting process. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em e}]an Event descriptor\end{description}
\end{Desc}
\begin{Desc}
\item[See also:]{\bf Event\_\-Wait()}{\rm (p.\,\pageref{os_8c_e279428ffa0e59261a01899cea931503})} \end{Desc}
\index{os.c@{os.c}!Event_Wait@{Event\_\-Wait}}
\index{Event_Wait@{Event\_\-Wait}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Event\_\-Wait ({\bf EVENT} $\ast$ {\em e})}\label{os_8c_e279428ffa0e59261a01899cea931503}


Wait for the next occurrence of a signal on {\em e\/}. The calling process always blocks. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em e}]an Event descriptor \end{description}
\end{Desc}
\index{os.c@{os.c}!main@{main}}
\index{main@{main}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int main ()}\label{os_8c_e66f6b31b5ad750f1fe042a706a4e3d4}


main function provided by user application. The first task to run. 

\index{os.c@{os.c}!OS_Abort@{OS\_\-Abort}}
\index{OS_Abort@{OS\_\-Abort}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void OS\_\-Abort (void)}\label{os_8c_b5747390a8be675282cb93e5198bd085}


Abort the execution of this RTOS due to an unrecoverable erorr. 

Abort the execution of this RTOS due to an unrecoverable erorr. \begin{Desc}
\item[See also:]{\bf GLOBAL ASSUMPTIONS}{\rm (p.\,\pageref{index_assumptions})}. \end{Desc}
\index{os.c@{os.c}!OS_Init@{OS\_\-Init}}
\index{OS_Init@{OS\_\-Init}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void OS\_\-Init (void)}\label{os_8c_280149a9407c6504ce0af541351561db}


Setup the RTOS and create {\bf main()}{\rm (p.\,\pageref{_assignment2_8c_840291bc02cba5474a4cb46a9b9566fe})} as the first SYSTEM level task. 

Point of entry from the C runtime crt0.S. \index{os.c@{os.c}!Signal_And_Next@{Signal\_\-And\_\-Next}}
\index{Signal_And_Next@{Signal\_\-And\_\-Next}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Signal\_\-And\_\-Next ({\bf EVENT} $\ast$ {\em e})}\label{os_8c_899044f5840427560c88d0d6e8944629}


Resume a waiting task on {\em e\/} and at the same time relinquish the processor. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em e}]an Event descriptor\end{description}
\end{Desc}
This is equivalent to \char`\"{}Event\_\-Signal( e ); Task\_\-Next()\char`\"{} in concept. The fundamental difference is that these two operations are performed as an indivisible unit. So conceptually, the calling task resumes another waiting task and gives up its share of the processor simultaneously. \begin{Desc}
\item[See also:]{\bf Event\_\-Signal()}{\rm (p.\,\pageref{os_8c_39210e081be158dab105c68cb85585cd})}, {\bf Task\_\-Next()}{\rm (p.\,\pageref{os_8c_5a9b72d0dadaea32fec8d4ff1c0eafa4})} \end{Desc}
\index{os.c@{os.c}!Task_Create@{Task\_\-Create}}
\index{Task_Create@{Task\_\-Create}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Task\_\-Create (void($\ast$)(void) {\em f}, int {\em arg}, unsigned int {\em level}, unsigned int {\em name})}\label{os_8c_d26f7e7c3185a703e89e97547747b03e}


\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em f}]a parameterless function to be created as a process instance \item[{\em arg}]an integer argument to be assigned to this process instanace \item[{\em level}]assigned scheduling level: SYSTEM, PERIODIC or RR \item[{\em name}]assigned PERIODIC process name \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]0 if not successful; otherwise non-zero. \end{Desc}
\begin{Desc}
\item[See also:]{\bf Task\_\-Get\-Arg()}{\rm (p.\,\pageref{os_8c_dc48a5ac983c4656508f39c0ee65283f})}, {\bf PPP}{\rm (p.\,\pageref{os_8h_9139cb65cf60e47afed151765972c100})}[].\end{Desc}
A new process is created to execute the parameterless function {\em f\/} with an initial parameter {\em arg\/}, which is retrieved by a call to {\bf Task\_\-Get\-Arg()}{\rm (p.\,\pageref{os_8c_dc48a5ac983c4656508f39c0ee65283f})}. If a new process cannot be created, 0 is returned; otherwise, it returns non-zero. The created process will belong to its scheduling {\em level\/}. If the process is PERIODIC, then its {\em name\/} is a user-specified name to be used in the PPP[] array. Otherwise, {\em name\/} is ignored. \begin{Desc}
\item[See also:]{\bf SCHEDULING POLICY}{\rm (p.\,\pageref{index_policy})} \end{Desc}
\index{os.c@{os.c}!Task_GetArg@{Task\_\-GetArg}}
\index{Task_GetArg@{Task\_\-GetArg}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Task\_\-Get\-Arg (void)}\label{os_8c_dc48a5ac983c4656508f39c0ee65283f}


Retrieve the assigned parameter. 

Retrieve the assigned parameter. \begin{Desc}
\item[See also:]{\bf Task\_\-Create()}{\rm (p.\,\pageref{os_8c_d26f7e7c3185a703e89e97547747b03e})}. \end{Desc}
\index{os.c@{os.c}!Task_Next@{Task\_\-Next}}
\index{Task_Next@{Task\_\-Next}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Task\_\-Next (void)}\label{os_8c_5a9b72d0dadaea32fec8d4ff1c0eafa4}


The calling task gives up its share of the processor voluntarily. 

Voluntarily relinquish the processor. \index{os.c@{os.c}!Task_Terminate@{Task\_\-Terminate}}
\index{Task_Terminate@{Task\_\-Terminate}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Task\_\-Terminate (void)}\label{os_8c_266ddbe2a3ded7e68eaa0d68a4047387}


The calling task terminates itself. 

Terminate the calling process

When a process returns, i.e., it executes its last instruction in the associated function/code, it is automatically terminated. \index{os.c@{os.c}!TIMER1_COMPA_vect@{TIMER1\_\-COMPA\_\-vect}}
\index{TIMER1_COMPA_vect@{TIMER1\_\-COMPA\_\-vect}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}TIMER1\_\-COMPA\_\-vect (void)}\label{os_8c_a5bea28826fceb06503c295132d2ac03}


The interrupt handler for output compare interrupts on Timer 1. 

Used to enter the kernel when a tick expires.

Assumption: We are still executing on the cur\_\-task stack. The return address inside the current task code is on the top of the stack.

The \char`\"{}naked\char`\"{} attribute prevents the compiler from adding instructions to save and restore register values. It also prevents an automatic return instruction. 

\subsection{Variable Documentation}
\index{os.c@{os.c}!PPP@{PPP}}
\index{PPP@{PPP}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}const unsigned char {\bf PPP}[$\,$]}\label{os_8c_9139cb65cf60e47afed151765972c100}


PPP and PT defined in user application. \index{os.c@{os.c}!PT@{PT}}
\index{PT@{PT}!os.c@{os.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}const unsigned int {\bf PT}}\label{os_8c_6370d00b2f49ebb4a69edf643003ada2}


PPP and PT defined in user application. 